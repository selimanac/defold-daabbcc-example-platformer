-- advanced_player.script
local const              = require("scripts.lib.const")
-- Configuration parameters
local MOVE_ACCELERATION  = 2000  -- pixels/sec^2 when accelerating
local MAX_MOVE_SPEED     = 200   -- maximum horizontal speed
local DECELERATION_LERP  = 0.19  -- smoothing factor (for vmath.lerp) when no input
local JUMP_FORCE         = 420   -- initial jump impulse
local GRAVITY_UP         = -1800 -- gravity while rising
local GRAVITY_DOWN       = -2500 -- gravity while falling (stronger for a snappier descent)
local MAX_JUMP_HOLD_TIME = 0.15  -- hold time (in seconds) to slightly reduce gravity

-- State variables
local velocity           = vmath.vector3(0)
local input_direction    = 0 -- -1 (left), 0, +1 (right)
local on_ground          = true
local jump_held          = false
local jump_timer         = 0
local is_walking         = false

-- Acquire input focus
function init(self)
	msg.post(".", "acquire_input_focus")
end

-- Process input actions for horizontal movement and jumping.
function on_input(self, action_id, action)
	if action_id == const.KEY.MOVE_LEFT then
		if action.pressed then
			input_direction = -1
		elseif action.released then
			if input_direction < 0 then input_direction = 0 end
		end
	elseif action_id == const.KEY.MOVE_RIGHT then
		if action.pressed then
			input_direction = 1
		elseif action.released then
			if input_direction > 0 then input_direction = 0 end
		end
	elseif action_id == const.KEY.JUMP then
		if action.pressed and on_ground then
			velocity.y = JUMP_FORCE
			on_ground = false
			jump_held = true
			jump_timer = 0
		elseif action.released then
			jump_held = false
		end
	end
end

-- Update the player position every frame.
function update(self, dt)
	local pos = go.get_position("/player")

	-- Horizontal movement:
	-- If an input is active, accelerate toward MAX_MOVE_SPEED.
	if input_direction ~= 0 then
		if not is_walking and on_ground then
			sprite.play_flipbook("/player#sprite", const.PLAYER.ANIM.RUN)
			is_walking = true
		elseif not on_ground then
			is_walking = false
		end

		sprite.set_hflip("/player#sprite", input_direction == -1)
		velocity.x = velocity.x + input_direction * MOVE_ACCELERATION * dt
		if math.abs(velocity.x) > MAX_MOVE_SPEED then
			velocity.x = input_direction * MAX_MOVE_SPEED
		end
	else
		if is_walking then
			sprite.play_flipbook("/player#sprite", const.PLAYER.ANIM.IDLE)
			is_walking = false
		end
		-- Smoothly decelerate when no input is pressed using vmath.lerp.
		velocity.x = vmath.lerp(DECELERATION_LERP, velocity.x, 0)
	end

	-- Vertical movement:
	-- While airborne, adjust gravity based on jump hold for a natural jump arc.
	if not on_ground then
		if jump_held and jump_timer < MAX_JUMP_HOLD_TIME and velocity.y > 0 then
			sprite.play_flipbook("/player#sprite", const.PLAYER.ANIM.JUMP)
			-- While jump is held, apply a gentler gravity so the ascent feels fast at the start and slows approaching the apex.
			velocity.y = velocity.y + (GRAVITY_UP * 0.5) * dt
			jump_timer = jump_timer + dt
		else
			-- Once the button is released or time expires, apply normal (or stronger) gravity.
			if velocity.y > 0 then
				velocity.y = velocity.y + GRAVITY_UP * dt
			else
				sprite.play_flipbook("/player#sprite", const.PLAYER.ANIM.FALL)
				velocity.y = velocity.y + GRAVITY_DOWN * dt
			end
		end
	end

	-- Update position using current velocity.
	pos = pos + velocity * dt

	-- Basic ground collision check (assume ground is at y = 0).
	if pos.y < 0 then
		if on_ground == false and not is_walking then
			sprite.play_flipbook("/player#sprite", const.PLAYER.ANIM.IDLE)
		end


		pos.y = 0
		velocity.y = 0
		on_ground = true
	end

	go.set_position(pos, "/player")
end
