local data        = require("scripts.lib.data")

-- camera.script

local DEADZONE    = vmath.vector3(30, 30, 0)       -- Deadzone width (x) and height (y)
local CAMERA_LERP = 5                              -- Smoothing factor; higher = faster catch-up
local BOUNDS_MIN  = vmath.vector3(-1025, -1768, 0) -- Minimum camera position (level left/bottom)
local BOUNDS_MAX  = vmath.vector3(1024, 1768, 0)   -- Maximum camera position (level right/top)
local PLAYER_ID   = hash("/player")                -- Make sure your player has this id

function init()
	go.set_position(data.player.position)
end

local function get_target_camera_pos(cam_pos, player_pos, deadzone)
	local offset = player_pos - cam_pos
	local target_offset = vmath.vector3(0, 0, 0)

	-- Horizontal deadzone check
	if offset.x > deadzone.x then
		target_offset.x = offset.x - deadzone.x
	elseif offset.x < -deadzone.x then
		target_offset.x = offset.x + deadzone.x
	end

	-- Vertical deadzone check
	if offset.y > deadzone.y then
		target_offset.y = offset.y - deadzone.y
	elseif player_pos.y < cam_pos.y then
		-- Fix: Follow the player exactly when falling (ignoring deadzone)
		target_offset.y = offset.y
	end

	return cam_pos + target_offset
end

function update(self, dt)
	local cam_pos = go.get_position()

	-- Determine the target position based on the player's position relative to the deadzone.
	local target_cam_pos = get_target_camera_pos(cam_pos, data.player.position, DEADZONE)
	-- Smoothly interpolate toward the target position.
	local new_cam_pos = vmath.lerp(CAMERA_LERP * dt, cam_pos, target_cam_pos)

	-- Clamp the camera position to the defined bounds.
	new_cam_pos.x = math.max(BOUNDS_MIN.x, math.min(BOUNDS_MAX.x, new_cam_pos.x))
	new_cam_pos.y = math.max(BOUNDS_MIN.y, math.min(BOUNDS_MAX.y, new_cam_pos.y))

	go.set_position(new_cam_pos)
end
